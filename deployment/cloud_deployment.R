#!/usr/bin/env Rscript
# Cloud Deployment Infrastructure for NHANES BMI Body Fat Analysis Platform
# Provides scalable cloud-native deployment with auto-scaling and monitoring

library(jsonlite)
library(yaml)
library(httr)
library(openssl)

# Cloud deployment configuration
CLOUD_CONFIG <- list(
  # Cloud provider settings
  provider = "aws",  # aws, gcp, azure
  region = "us-east-1",
  availability_zones = c("us-east-1a", "us-east-1b", "us-east-1c"),

  # Application settings
  app_name = "nhanes-bmi-analysis",
  environment = "production",
  domain = "nhanes-analysis.example.com",

  # Infrastructure settings
  instance_type = "t3.medium",
  min_instances = 2,
  max_instances = 10,
  desired_instances = 3,

  # Database settings
  database = list(
    engine = "postgresql",
    instance_class = "db.t3.micro",
    allocated_storage = 20,
    backup_retention = 7
  ),

  # Storage settings
  storage = list(
    bucket_name = "nhanes-analysis-data",
    region = "us-east-1",
    versioning = TRUE,
    lifecycle_policy = TRUE
  ),

  # Monitoring settings
  monitoring = list(
    enable_cloudwatch = TRUE,
    enable_alarms = TRUE,
    log_retention_days = 30,
    metrics_retention_days = 90
  ),

  # Security settings
  security = list(
    ssl_certificate = TRUE,
    firewall_enabled = TRUE,
    encryption_at_rest = TRUE,
    access_logging = TRUE
  )
)

# Infrastructure as Code Templates

#' Generate Terraform configuration for AWS deployment
#'
#' @param config Cloud deployment configuration
#' @return Terraform configuration as string
generate_terraform_config <- function(config = CLOUD_CONFIG) {

  terraform_config <- paste0(
    "# Terraform Configuration for NHANES BMI Analysis Platform\n",
    "# Generated by cloud_deployment.R\n\n",

    "terraform {\n",
    "  required_providers {\n",
    "    aws = {\n",
      "      source  = \"hashicorp/aws\"\n",
      "      version = \"~> 4.0\"\n",
    "    }\n",
    "  }\n",
    "}\n\n",

    "# Configure AWS provider\n",
    "provider \"aws\" {\n",
    "  region = \"", config$region, "\"\n",
    "}\n\n",

    "# VPC for application\n",
    "resource \"aws_vpc\" \"main\" {\n",
    "  cidr_block = \"10.0.0.0/16\"\n",
    "  enable_dns_hostnames = true\n",
    "  enable_dns_support = true\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-vpc\"\n",
    "    Environment = \"", config$environment, "\"\n",
    "  }\n",
    "}\n\n",

    "# Internet Gateway\n",
    "resource \"aws_internet_gateway\" \"main\" {\n",
    "  vpc_id = aws_vpc.main.id\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-igw\"\n",
    "  }\n",
    "}\n\n",

    "# Public subnets\n",
    "resource \"aws_subnet\" \"public\" {\n",
    "  count = length(data.aws_availability_zones.available.names)\n\n",
    "  vpc_id = aws_vpc.main.id\n",
    "  cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 8, count.index)\n",
    "  availability_zone = data.aws_availability_zones.available.names[count.index]\n",
    "  map_public_ip_on_launch = true\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-public-${count.index + 1}\"\n",
    "  }\n",
    "}\n\n",

    "# Private subnets\n",
    "resource \"aws_subnet\" \"private\" {\n",
    "  count = length(data.aws_availability_zones.available.names)\n\n",
    "  vpc_id = aws_vpc.main.id\n",
    "  cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 8, count.index + 10)\n",
    "  availability_zone = data.aws_availability_zones.available.names[count.index]\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-private-${count.index + 1}\"\n",
    "  }\n",
    "}\n\n",

    "# NAT Gateways\n",
    "resource \"aws_eip\" \"nat\" {\n",
    "  count = length(data.aws_availability_zones.available.names)\n",
    "  vpc = true\n",
    "}\n\n",

    "resource \"aws_nat_gateway\" \"main\" {\n",
    "  count = length(data.aws_availability_zones.available.names)\n\n",
    "  allocation_id = aws_eip.nat[count.index].id\n",
    "  subnet_id = aws_subnet.public[count.index].id\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-nat-${count.index + 1}\"\n",
    "  }\n",
    "}\n\n",

    "# Route tables\n",
    "resource \"aws_route_table\" \"public\" {\n",
    "  vpc_id = aws_vpc.main.id\n\n",
    "  route {\n",
    "    cidr_block = \"0.0.0.0/0\"\n",
    "    gateway_id = aws_internet_gateway.main.id\n",
    "  }\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-public-rt\"\n",
    "  }\n",
    "}\n\n",

    "resource \"aws_route_table\" \"private\" {\n",
    "  count = length(data.aws_availability_zones.available.names)\n\n",
    "  vpc_id = aws_vpc.main.id\n\n",
    "  route {\n",
    "    cidr_block = \"0.0.0.0/0\"\n",
    "    nat_gateway_id = aws_nat_gateway.main[count.index].id\n",
    "  }\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-private-rt-${count.index + 1}\"\n",
    "  }\n",
    "}\n\n",

    "# Route table associations\n",
    "resource \"aws_route_table_association\" \"public\" {\n",
    "  count = length(data.aws_availability_zones.available.names)\n\n",
    "  subnet_id = aws_subnet.public[count.index].id\n",
    "  route_table_id = aws_route_table.public.id\n",
    "}\n\n",

    "resource \"aws_route_table_association\" \"private\" {\n",
    "  count = length(data.aws_availability_zones.available.names)\n\n",
    "  subnet_id = aws_subnet.private[count.index].id\n",
    "  route_table_id = aws_route_table.private[count.index].id\n",
    "}\n\n",

    "# Security groups\n",
    "resource \"aws_security_group\" \"web\" {\n",
    "  name_prefix = \"", config$app_name, "-web-\"\n",
    "  vpc_id = aws_vpc.main.id\n\n",
    "  ingress {\n",
    "    from_port = 80\n",
    "    to_port = 80\n",
    "    protocol = \"tcp\"\n",
    "    cidr_blocks = [\"0.0.0.0/0\"]\n",
    "  }\n\n",
    "  ingress {\n",
    "    from_port = 443\n",
    "    to_port = 443\n",
    "    protocol = \"tcp\"\n",
    "    cidr_blocks = [\"0.0.0.0/0\"]\n",
    "  }\n\n",
    "  ingress {\n",
    "    from_port = 3838\n",
    "    to_port = 3838\n",
    "    protocol = \"tcp\"\n",
    "    cidr_blocks = [\"0.0.0.0/0\"]\n",
    "  }\n\n",
    "  ingress {\n",
    "    from_port = 8000\n",
    "    to_port = 8000\n",
    "    protocol = \"tcp\"\n",
    "    cidr_blocks = [\"0.0.0.0/0\"]\n",
    "  }\n\n",
    "  egress {\n",
    "    from_port = 0\n",
    "    to_port = 0\n",
    "    protocol = \"-1\"\n",
    "    cidr_blocks = [\"0.0.0.0/0\"]\n",
    "  }\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-web-sg\"\n",
    "  }\n",
    "}\n\n",

    "# Load balancer\n",
    "resource \"aws_lb\" \"main\" {\n",
    "  name = \"", config$app_name, "-alb\"\n",
    "  internal = false\n",
    "  load_balancer_type = \"application\"\n",
    "  security_groups = [aws_security_group.web.id]\n",
    "  subnets = aws_subnet.public[*].id\n\n",
    "  enable_deletion_protection = false\n",
    "  enable_cross_zone_load_balancing = true\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-alb\"\n",
    "    Environment = \"", config$environment, "\"\n",
    "  }\n",
    "}\n\n",

    "# Load balancer target group\n",
    "resource \"aws_lb_target_group\" \"main\" {\n",
    "  name = \"", config$app_name, "-tg\"\n",
    "  port = 8000\n",
    "  protocol = \"HTTP\"\n",
    "  vpc_id = aws_vpc.main.id\n",
    "  target_type = \"ip\"\n\n",
    "  health_check {\n",
    "    enabled = true\n",
    "    healthy_threshold = 2\n",
    "    unhealthy_threshold = 2\n",
    "    timeout = 5\n",
    "    interval = 30\n",
    "    path = \"/health\"\n",
    "    matcher = \"200\"\n",
    "  }\n\n",
    "  stickiness {\n",
    "    type = \"lb_cookie\"\n",
    "    cookie_duration = 1800\n",
    "    enabled = false\n",
    "  }\n",
    "}\n\n",

    "# Load balancer listener\n",
    "resource \"aws_lb_listener\" \"main\" {\n",
    "  load_balancer_arn = aws_lb.main.arn\n",
    "  port = \"80\"\n",
    "  protocol = \"HTTP\"\n\n",
    "  default_action {\n",
    "    type = \"forward\"\n",
    "    target_group_arn = aws_lb_target_group.main.arn\n",
    "  }\n",
    "}\n\n",

    "# ECS cluster\n",
    "resource \"aws_ecs_cluster\" \"main\" {\n",
    "  name = \"", config$app_name, "-cluster\"\n\n",
    "  capacity_providers = [\"FARGATE\", \"FARGATE_SPOT\"]\n\n",
    "  default_capacity_provider_strategy {\n",
    "    capacity_provider = \"FARGATE\"\n",
    "    weight = 100\n",
    "  }\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-cluster\"\n",
    "    Environment = \"", config$environment, "\"\n",
    "  }\n",
    "}\n\n",

    "# ECS task definition\n",
    "resource \"aws_ecs_task_definition\" \"main\" {\n",
    "  family = \"", config$app_name, "-task\"\n",
    "  network_mode = \"awsvpc\"\n",
    "  requires_compatibilities = [\"FARGATE\"]\n",
    "  cpu = \"256\"\n",
    "  memory = \"512\"\n",
    "  execution_role_arn = aws_iam_role.ecs_execution_role.arn\n",
    "  task_role_arn = aws_iam_role.ecs_task_role.arn\n\n",
    "  container_definitions = jsonencode([\n",
    "    {\n",
    "      name = \"", config$app_name, "-container\"\n",
    "      image = \"", config$app_name, ":latest\"\n",
    "      essential = true\n",
    "      memory = 512\n",
    "      cpu = 256\n",
    "      portMappings = [\n",
    "        {\n",
    "          containerPort = 8000\n",
    "          hostPort = 8000\n",
    "          protocol = \"tcp\"\n",
    "        },\n",
    "        {\n",
    "          containerPort = 3838\n",
    "          hostPort = 3838\n",
    "          protocol = \"tcp\"\n",
    "        }\n",
    "      ]\n",
    "      environment = [\n",
    "        {\n",
    "          name = \"ENVIRONMENT\"\n",
    "          value = \"", config$environment, "\"\n",
    "        }\n",
    "      ]\n",
    "      logConfiguration = {\n",
    "        logDriver = \"awslogs\"\n",
    "        options = {\n",
    "          \"awslogs-group\" = \"/ecs/", config$app_name, "\"\n",
    "          \"awslogs-region\" = \"", config$region, "\"\n",
    "          \"awslogs-stream-prefix\" = \"ecs\"\n",
    "        }\n",
    "      }\n",
    "      healthCheck = {\n",
    "        command = [\n",
    "          \"CMD-SHELL\",\n",
    "          \"curl -f http://localhost:8000/health || exit 1\"\n",
    "        ]\n",
    "        interval = 30\n",
    "        timeout = 5\n",
    "        retries = 3\n",
    "        startPeriod = 60\n",
    "      }\n",
    "    }\n",
    "  ])\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-task\"\n",
    "    Environment = \"", config$environment, "\"\n",
    "  }\n",
    "}\n\n",

    "# ECS service\n",
    "resource \"aws_ecs_service\" \"main\" {\n",
    "  name = \"", config$app_name, "-service\"\n",
    "  cluster = aws_ecs_cluster.main.id\n",
    "  task_definition = aws_ecs_task_definition.main.arn\n",
    "  desired_count = ", config$desired_instances, "\n",
    "  launch_type = \"FARGATE\"\n\n",
    "  network_configuration {\n",
    "    security_groups = [aws_security_group.web.id]\n",
    "    subnets = aws_subnet.private[*].id\n",
    "    assign_public_ip = false\n",
    "  }\n\n",
    "  load_balancer {\n",
    "    target_group_arn = aws_lb_target_group.main.arn\n",
    "    container_name = \"", config$app_name, "-container\"\n",
    "    container_port = 8000\n",
    "  }\n\n",
    "  depends_on = [aws_lb_listener.main]\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-service\"\n",
    "    Environment = \"", config$environment, "\"\n",
    "  }\n",
    "}\n\n",

    "# Auto scaling\n",
    "resource \"aws_appautoscaling_target\" \"main\" {\n",
    "  max_capacity = ", config$max_instances, "\n",
    "  min_capacity = ", config$min_instances, "\n",
    "  resource_id = \"service/", aws_ecs_cluster.main.name, "/", aws_ecs_service.main.name, "\"\n",
    "  scalable_dimension = \"ecs:service:DesiredCount\"\n",
    "  service_namespace = \"ecs\"\n",
    "}\n\n",

    "# CPU scaling policy\n",
    "resource \"aws_appautoscaling_policy\" \"cpu\" {\n",
    "  name = \"", config$app_name, "-cpu-scaling\"\n",
    "  policy_type = \"TargetTrackingScaling\"\n",
    "  resource_id = aws_appautoscaling_target.main.resource_id\n",
    "  scalable_dimension = aws_appautoscaling_target.main.scalable_dimension\n",
    "  service_namespace = aws_appautoscaling_target.main.service_namespace\n\n",
    "  target_tracking_scaling_policy_configuration {\n",
    "    predefined_metric_specification {\n",
    "      predefined_metric_type = \"ECSServiceAverageCPUUtilization\"\n",
    "    }\n",
    "    target_value = 70.0\n",
    "  }\n",
    "}\n\n",

    "# Memory scaling policy\n",
    "resource \"aws_appautoscaling_policy\" \"memory\" {\n",
    "  name = \"", config$app_name, "-memory-scaling\"\n",
    "  policy_type = \"TargetTrackingScaling\"\n",
    "  resource_id = aws_appautoscaling_target.main.resource_id\n",
    "  scalable_dimension = aws_appautoscaling_target.main.scalable_dimension\n",
    "  service_namespace = aws_appautoscaling_target.main.service_namespace\n\n",
    "  target_tracking_scaling_policy_configuration {\n",
    "    predefined_metric_specification {\n",
    "      predefined_metric_type = \"ECSServiceAverageMemoryUtilization\"\n",
    "    }\n",
    "    target_value = 80.0\n",
    "  }\n",
    "}\n\n",

    "# RDS database\n",
    "resource \"aws_db_instance\" \"main\" {\n",
    "  identifier = \"", config$app_name, "-db\"\n",
    "  engine = \"", config$database$engine, "\"\n",
    "  engine_version = \"13.7\"\n",
    "  instance_class = \"", config$database$instance_class, "\"\n",
    "  allocated_storage = ", config$database$allocated_storage, "\n",
    "  storage_type = \"gp2\"\n",
    "  db_name = \"nhanes_analysis\"\n",
    "  username = \"admin\"\n",
    "  password = random_password.db_password.result\n",
    "  backup_retention_period = ", config$database$backup_retention, "\n",
    "  backup_window = \"03:00-04:00\"\n",
    "  maintenance_window = \"sun:04:00-sun:05:00\"\n",
    "  skip_final_snapshot = true\n",
    "  publicly_accessible = false\n",
    "  vpc_security_group_ids = [aws_security_group.db.id]\n",
    "  db_subnet_group_name = aws_db_subnet_group.main.name\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-db\"\n",
    "    Environment = \"", config$environment, "\"\n",
    "  }\n",
    "}\n\n",

    "# Database subnet group\n",
    "resource \"aws_db_subnet_group\" \"main\" {\n",
    "  name = \"", config$app_name, "-db-subnet-group\"\n",
    "  subnet_ids = aws_subnet.private[*].id\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-db-subnet-group\"\n",
    "  }\n",
    "}\n\n",

    "# Database security group\n",
    "resource \"aws_security_group\" \"db\" {\n",
    "  name_prefix = \"", config$app_name, "-db-\"\n",
    "  vpc_id = aws_vpc.main.id\n\n",
    "  ingress {\n",
    "    from_port = 5432\n",
    "    to_port = 5432\n",
    "    protocol = \"tcp\"\n",
    "    security_groups = [aws_security_group.web.id]\n",
    "  }\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-db-sg\"\n",
    "  }\n",
    "}\n\n",

    "# S3 bucket for data storage\n",
    "resource \"aws_s3_bucket\" \"data\" {\n",
    "  bucket = \"", config$storage$bucket_name, "\"\n",
    "  acl = \"private\"\n\n",
    "  versioning {\n",
    "    enabled = ", tolower(as.character(config$storage$versioning)), "\n",
    "  }\n\n",
    "  lifecycle_rule {\n",
    "    id = \"data_lifecycle\"\n",
    "    enabled = ", tolower(as.character(config$storage$lifecycle_policy)), "\n\n",
    "    transition {\n",
    "      days = 30\n",
    "      storage_class = \"STANDARD_IA\"\n",
    "    }\n\n",
    "    transition {\n",
    "      days = 90\n",
    "      storage_class = \"GLACIER\"\n",
    "    }\n\n",
    "    expiration {\n",
    "      days = 365\n",
    "    }\n",
    "  }\n\n",
    "  server_side_encryption_configuration {\n",
    "    rule {\n",
    "      apply_server_side_encryption_by_default {\n",
    "        sse_algorithm = \"AES256\"\n",
    "      }\n",
    "    }\n",
    "  }\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-data-bucket\"\n",
    "    Environment = \"", config$environment, "\"\n",
    "  }\n",
    "}\n\n",

    "# CloudWatch log group\n",
    "resource \"aws_cloudwatch_log_group\" \"main\" {\n",
    "  name = \"/ecs/", config$app_name, "\"\n",
    "  retention_in_days = ", config$monitoring$log_retention_days, "\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-log-group\"\n",
    "    Environment = \"", config$environment, "\"\n",
    "  }\n",
    "}\n\n",

    "# CloudWatch alarms\n",
    "resource \"aws_cloudwatch_metric_alarm\" \"cpu_high\" {\n",
    "  alarm_name = \"", config$app_name, "-cpu-high\"\n",
    "  comparison_operator = \"GreaterThanThreshold\"\n",
    "  evaluation_periods = \"2\"\n",
    "  metric_name = \"CPUUtilization\"\n",
    "  namespace = \"AWS/ECS\"\n",
    "  period = \"300\"\n",
    "  statistic = \"Average\"\n",
    "  threshold = \"80\"\n",
    "  alarm_description = \"This metric monitors ECS CPU utilization\"\n",
    "  alarm_actions = [aws_sns_topic.alerts.arn]\n\n",
    "  dimensions = {\n",
    "    ServiceName = aws_ecs_service.main.name\n",
    "    ClusterName = aws_ecs_cluster.main.name\n",
    "  }\n",
    "}\n\n",

    "resource \"aws_cloudwatch_metric_alarm\" \"memory_high\" {\n",
    "  alarm_name = \"", config$app_name, "-memory-high\"\n",
    "  comparison_operator = \"GreaterThanThreshold\"\n",
    "  evaluation_periods = \"2\"\n",
    "  metric_name = \"MemoryUtilization\"\n",
    "  namespace = \"AWS/ECS\"\n",
    "  period = \"300\"\n",
    "  statistic = \"Average\"\n",
    "  threshold = \"85\"\n",
    "  alarm_description = \"This metric monitors ECS memory utilization\"\n",
    "  alarm_actions = [aws_sns_topic.alerts.arn]\n\n",
    "  dimensions = {\n",
    "    ServiceName = aws_ecs_service.main.name\n",
    "    ClusterName = aws_ecs_cluster.main.name\n",
    "  }\n",
    "}\n\n",

    "# SNS topic for alerts\n",
    "resource \"aws_sns_topic\" \"alerts\" {\n",
    "  name = \"", config$app_name, "-alerts\"\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-alerts\"\n",
    "    Environment = \"", config$environment, "\"\n",
    "  }\n",
    "}\n\n",

    "# IAM roles\n",
    "resource \"aws_iam_role\" \"ecs_execution_role\" {\n",
    "  name = \"", config$app_name, "-ecs-execution-role\"\n\n",
    "  assume_role_policy = jsonencode({\n",
    "    Version = \"2012-10-17\"\n",
    "    Statement = [\n",
    "      {\n",
    "        Action = \"sts:AssumeRole\"\n",
    "        Effect = \"Allow\"\n",
    "        Principal = {\n",
    "          Service = \"ecs-tasks.amazonaws.com\"\n",
    "        }\n",
    "      }\n",
    "    ]\n",
    "  })\n\n",
    "  managed_policy_arns = [\n",
    "    \"arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\"\n",
    "  ]\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-ecs-execution-role\"\n",
    "  }\n",
    "}\n\n",

    "resource \"aws_iam_role\" \"ecs_task_role\" {\n",
    "  name = \"", config$app_name, "-ecs-task-role\"\n\n",
    "  assume_role_policy = jsonencode({\n",
    "    Version = \"2012-10-17\"\n",
    "    Statement = [\n",
    "      {\n",
    "        Action = \"sts:AssumeRole\"\n",
    "        Effect = \"Allow\"\n",
    "        Principal = {\n",
    "          Service = \"ecs-tasks.amazonaws.com\"\n",
    "        }\n",
    "      }\n",
    "    ]\n",
    "  })\n\n",
    "  inline_policy {\n",
    "    name = \"", config$app_name, "-task-policy\"\n",
    "    policy = jsonencode({\n",
    "      Version = \"2012-10-17\"\n",
    "      Statement = [\n",
    "        {\n",
    "          Action = [\n",
    "            \"s3:GetObject\",\n",
    "            \"s3:PutObject\",\n",
    "            \"s3:ListBucket\"\n",
    "          ]\n",
    "          Effect = \"Allow\"\n",
    "          Resource = [\n",
    "            aws_s3_bucket.data.arn,\n",
    "            \"${aws_s3_bucket.data.arn}/*\"\n",
    "          ]\n",
    "        },\n",
    "        {\n",
    "          Action = [\n",
    "            \"logs:CreateLogStream\",\n",
    "            \"logs:CreateLogGroup\",\n",
    "            \"logs:PutLogEvents\"\n",
    "          ]\n",
    "          Effect = \"Allow\"\n",
    "          Resource = \"*\"\n",
    "        }\n",
    "      ]\n",
    "    })\n",
    "  }\n\n",
    "  tags = {\n",
    "    Name = \"", config$app_name, "-ecs-task-role\"\n",
    "  }\n",
    "}\n\n",

    "# Random password for database\n",
    "resource \"random_password\" \"db_password\" {\n",
    "  length = 32\n",
    "  special = true\n",
    "  override_special = \"!#$%^&*()_+-=[]{}|':?\"\n",
    "}\n\n",

    "# Outputs\n",
    "output \"load_balancer_dns_name\" {\n",
    "  value = aws_lb.main.dns_name\n",
    "  description = \"DNS name of the load balancer\"\n",
    "}\n\n",

    "output \"database_endpoint\" {\n",
    "  value = aws_db_instance.main.endpoint\n",
    "  description = \"Database endpoint\"\n",
    "}\n\n",

    "output \"s3_bucket_name\" {\n",
    "  value = aws_s3_bucket.data.bucket\n",
    "  description = \"S3 bucket name for data storage\"\n",
    "}\n\n",

    "output \"ecs_cluster_name\" {\n",
    "  value = aws_ecs_cluster.main.name\n",
    "  description = \"ECS cluster name\"\n",
    "}\n"
  )

  return(terraform_config)
}

#' Generate Kubernetes deployment configuration
#'
#' @param config Cloud deployment configuration
#' @return Kubernetes YAML configuration
generate_kubernetes_config <- function(config = CLOUD_CONFIG) {

  k8s_config <- list(
    apiVersion = "v1",
    kind = "Namespace",
    metadata = list(
      name = config$app_name,
      labels = list(
        app = config$app_name,
        environment = config$environment
      )
    )
  )

  # Deployment
  deployment <- list(
    apiVersion = "apps/v1",
    kind = "Deployment",
    metadata = list(
      name = paste0(config$app_name, "-deployment"),
      namespace = config$app_name,
      labels = list(
        app = config$app_name,
        component = "api"
      )
    ),
    spec = list(
      replicas = config$desired_instances,
      selector = list(
        matchLabels = list(
          app = config$app_name,
          component = "api"
        )
      ),
      template = list(
        metadata = list(
          labels = list(
            app = config$app_name,
            component = "api"
          )
        ),
        spec = list(
          containers = list(
            list(
              name = config$app_name,
              image = paste0(config$app_name, ":latest"),
              ports = list(
                list(containerPort = 8000, name = "api"),
                list(containerPort = 3838, name = "shiny")
              ),
              env = list(
                list(name = "ENVIRONMENT", value = config$environment),
                list(name = "DATABASE_URL", valueFrom = list(secretKeyRef = list(
                  name = paste0(config$app_name, "-secrets"),
                  key = "database_url"
                ))),
                list(name = "AWS_ACCESS_KEY_ID", valueFrom = list(secretKeyRef = list(
                  name = paste0(config$app_name, "-secrets"),
                  key = "aws_access_key_id"
                ))),
                list(name = "AWS_SECRET_ACCESS_KEY", valueFrom = list(secretKeyRef = list(
                  name = paste0(config$app_name, "-secrets"),
                  key = "aws_secret_access_key"
                )))
              ),
              resources = list(
                requests = list(
                  memory = "256Mi",
                  cpu = "250m"
                ),
                limits = list(
                  memory = "1Gi",
                  cpu = "1000m"
                )
              ),
              livenessProbe = list(
                httpGet = list(
                  path = "/health",
                  port = 8000
                ),
                initialDelaySeconds = 60,
                periodSeconds = 30,
                timeoutSeconds = 5,
                failureThreshold = 3
              ),
              readinessProbe = list(
                httpGet = list(
                  path = "/health",
                  port = 8000
                ),
                initialDelaySeconds = 30,
                periodSeconds = 10,
                timeoutSeconds = 3,
                failureThreshold = 3
              )
            )
          )
        )
      )
    )
  )

  # Service
  service <- list(
    apiVersion = "v1",
    kind = "Service",
    metadata = list(
      name = paste0(config$app_name, "-service"),
      namespace = config$app_name,
      labels = list(
        app = config$app_name,
        component = "api"
      )
    ),
    spec = list(
      selector = list(
        app = config$app_name,
        component = "api"
      ),
      ports = list(
        list(port = 80, targetPort = 8000, name = "api"),
        list(port = 3838, targetPort = 3838, name = "shiny")
      ),
      type = "ClusterIP"
    )
  )

  # Ingress
  ingress <- list(
    apiVersion = "networking.k8s.io/v1",
    kind = "Ingress",
    metadata = list(
      name = paste0(config$app_name, "-ingress"),
      namespace = config$app_name,
      annotations = list(
        "kubernetes.io/ingress.class" = "nginx",
        "cert-manager.io/cluster-issuer" = "letsencrypt-prod",
        "nginx.ingress.kubernetes.io/rewrite-target" = "/$2"
      )
    ),
    spec = list(
      tls = list(
        list(
          hosts = list(config$domain),
          secretName = paste0(config$app_name, "-tls")
        )
      ),
      rules = list(
        list(
          host = config$domain,
          http = list(
            paths = list(
              list(
                path = "/()(.*)",
                pathType = "Prefix",
                backend = list(
                  service = list(
                    name = paste0(config$app_name, "-service"),
                    port = list(number = 80)
                  )
                )
              )
            )
          )
        )
      )
    )
  )

  # ConfigMap for application settings
  configmap <- list(
    apiVersion = "v1",
    kind = "ConfigMap",
    metadata = list(
      name = paste0(config$app_name, "-config"),
      namespace = config$app_name
    ),
    data = list(
      ENVIRONMENT = config$environment,
      LOG_LEVEL = "INFO",
      MAX_WORKERS = as.character(config$parallel_cores),
      CACHE_ENABLED = "TRUE",
      BACKUP_ENABLED = "TRUE"
    )
  )

  # Secret for sensitive data
  secret <- list(
    apiVersion = "v1",
    kind = "Secret",
    metadata = list(
      name = paste0(config$app_name, "-secrets"),
      namespace = config$app_name
    ),
    type = "Opaque",
    data = list(
      database_url = openssl::base64_encode(paste0("postgresql://admin:", random_password.db_password.result, "@", aws_db_instance.main.endpoint, "/nhanes_analysis")),
      aws_access_key_id = openssl::base64_encode("your_access_key"),
      aws_secret_access_key = openssl::base64_encode("your_secret_key")
    )
  )

  return(list(
    namespace = k8s_config,
    deployment = deployment,
    service = service,
    ingress = ingress,
    configmap = configmap,
    secret = secret
  ))
}

#' Generate Docker Compose for local development
#'
#' @param config Cloud deployment configuration
#' @return Docker Compose configuration
generate_docker_compose_dev <- function(config = CLOUD_CONFIG) {

  compose_config <- paste0(
    "version: '3.8'\n\n",
    "services:\n",
    "  nhanes-api:\n",
    "    build: .\n",
    "    image: ", config$app_name, ":dev\n",
    "    container_name: ", config$app_name, "-dev\n",
    "    ports:\n",
    "      - \"8000:8000\"  # API server\n",
    "      - \"3838:3838\"  # Shiny apps\n",
    "    volumes:\n",
    "      - ./data:/app/data\n",
    "      - ./outputs:/app/outputs\n",
    "      - ./cache:/app/cache\n",
    "      - ./config:/app/config\n",
    "    environment:\n",
    "      - ENVIRONMENT=development\n",
    "      - LOG_LEVEL=DEBUG\n",
    "      - MAX_WORKERS=4\n",
    "      - CACHE_ENABLED=TRUE\n",
    "    restart: unless-stopped\n",
    "    healthcheck:\n",
    "      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n",
    "      interval: 30s\n",
    "      timeout: 10s\n",
    "      retries: 3\n",
    "      start_period: 60s\n",
    "\n",
    "  postgres:\n",
    "    image: postgres:13\n",
    "    container_name: ", config$app_name, "-db\n",
    "    environment:\n",
    "      - POSTGRES_DB=nhanes_analysis\n",
    "      - POSTGRES_USER=admin\n",
    "      - POSTGRES_PASSWORD=dev_password\n",
    "    volumes:\n",
    "      - postgres_data:/var/lib/postgresql/data\n",
    "    ports:\n",
    "      - \"5432:5432\"\n",
    "    restart: unless-stopped\n",
    "\n",
    "  redis:\n",
    "    image: redis:7-alpine\n",
    "    container_name: ", config$app_name, "-redis\n",
    "    ports:\n",
    "      - \"6379:6379\"\n",
    "    restart: unless-stopped\n",
    "    command: redis-server --appendonly yes\n",
    "    volumes:\n",
    "      - redis_data:/data\n",
    "\n",
    "  nginx:\n",
    "    image: nginx:alpine\n",
    "    container_name: ", config$app_name, "-nginx\n",
    "    ports:\n",
    "      - \"80:80\"\n",
    "      - \"443:443\"\n",
    "    volumes:\n",
    "      - ./nginx.conf:/etc/nginx/nginx.conf\n",
    "      - ./ssl:/etc/nginx/ssl\n",
    "    restart: unless-stopped\n",
    "    depends_on:\n",
    "      - nhanes-api\n",
    "\n",
    "volumes:\n",
    "  postgres_data:\n",
    "  redis_data:\n"
  )

  return(compose_config)
}

#' Generate deployment script
#'
#' @param provider Cloud provider
#' @return Deployment script
generate_deployment_script <- function(provider = "aws") {

  script <- switch(provider,
    "aws" = paste0(
      "#!/bin/bash\n",
      "# AWS Deployment Script for NHANES BMI Body Fat Analysis Platform\n\n",
      "# Set variables\n",
      "REGION=", CLOUD_CONFIG$region, "\n",
      "CLUSTER_NAME=", CLOUD_CONFIG$app_name, "-cluster\n",
      "SERVICE_NAME=", CLOUD_CONFIG$app_name, "-service\n",
      "IMAGE_NAME=", CLOUD_CONFIG$app_name, "\n",
      "TAG=latest\n\n",
      "# Configure AWS CLI\n",
      "aws configure set region $REGION\n\n",
      "# Build and push Docker image\n",
      "echo \"🔨 Building Docker image...\"\n",
      "docker build -t $IMAGE_NAME:$TAG .\n",
      "aws ecr get-login-password --region $REGION | docker login --username AWS --password-stdin $(aws sts get-caller-identity --query Account --output text).dkr.ecr.$REGION.amazonaws.com\n",
      "docker tag $IMAGE_NAME:$TAG $(aws sts get-caller-identity --query Account --output text).dkr.ecr.$REGION.amazonaws.com/$IMAGE_NAME:$TAG\n",
      "docker push $(aws sts get-caller-identity --query Account --output text).dkr.ecr.$REGION.amazonaws.com/$IMAGE_NAME:$TAG\n\n",
      "# Update ECS service\n",
      "echo \"🚀 Updating ECS service...\"\n",
      "aws ecs update-service --cluster $CLUSTER_NAME --service $SERVICE_NAME --force-new-deployment\n\n",
      "# Wait for deployment to complete\n",
      "echo \"⏳ Waiting for deployment to complete...\"\n",
      "aws ecs wait services-stable --cluster $CLUSTER_NAME --services $SERVICE_NAME\n\n",
      "# Check service health\n",
      "echo \"🏥 Checking service health...\"\n",
      "SERVICE_URL=$(aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --query 'services[0].loadBalancers[0].dnsName' --output text)\n",
      "if curl -f http://$SERVICE_URL/health >/dev/null 2>&1; then\n",
      "  echo \"✅ Deployment successful!\"\n",
      "  echo \"🌐 Service available at: http://$SERVICE_URL\"\n",
      "else\n",
      "  echo \"❌ Deployment failed!\"\n",
      "  echo \"Check ECS service logs for details\"\n",
      "  exit 1\n",
      "fi\n"
    ),
    "gcp" = paste0(
      "#!/bin/bash\n",
      "# GCP Deployment Script\n",
      "# Implementation for Google Cloud Platform\n\n",
      "echo \"🚀 GCP deployment not yet implemented\"\n",
      "echo \"💡 Use: gcloud run deploy --source . --platform managed\"\n"
    ),
    "azure" = paste0(
      "#!/bin/bash\n",
      "# Azure Deployment Script\n",
      "# Implementation for Microsoft Azure\n\n",
      "echo \"🚀 Azure deployment not yet implemented\"\n",
      "echo \"💡 Use: az container create --resource-group <group> --name <name> --image <image>\"\n"
    )
  )

  return(script)
}

#' Create cloud deployment infrastructure
#'
#' @param provider Cloud provider
#' @param config Cloud deployment configuration
#' @return Deployment status
create_cloud_infrastructure <- function(provider = "aws", config = CLOUD_CONFIG) {

  cat("☁️ Creating cloud infrastructure for", provider, "...\n")

  # Generate configuration files
  if (provider == "aws") {
    # Generate Terraform configuration
    terraform_config <- generate_terraform_config(config)
    writeLines(terraform_config, "deployment/terraform/main.tf")

    # Generate variables file
    variables_tf <- paste0(
      "variable \"aws_region\" {\n",
      "  description = \"AWS region\"\n",
      "  default = \"", config$region, "\"\n",
      "}\n\n",
      "variable \"app_name\" {\n",
      "  description = \"Application name\"\n",
      "  default = \"", config$app_name, "\"\n",
      "}\n\n",
      "variable \"environment\" {\n",
      "  description = \"Environment name\"\n",
      "  default = \"", config$environment, "\"\n",
      "}\n"
    )
    writeLines(variables_tf, "deployment/terraform/variables.tf")

    # Generate outputs file
    outputs_tf <- paste0(
      "output \"load_balancer_dns\" {\n",
      "  value = aws_lb.main.dns_name\n",
      "  description = \"Load balancer DNS name\"\n",
      "}\n\n",
      "output \"database_endpoint\" {\n",
      "  value = aws_db_instance.main.endpoint\n",
      "  description = \"Database endpoint\"\n",
      "}\n\n",
      "output \"s3_bucket\" {\n",
      "  value = aws_s3_bucket.data.bucket\n",
      "  description = \"S3 bucket name\"\n",
      "}\n"
    )
    writeLines(outputs_tf, "deployment/terraform/outputs.tf")

    cat("✅ Generated Terraform configuration\n")

  } else if (provider == "kubernetes") {
    # Generate Kubernetes manifests
    k8s_config <- generate_kubernetes_config(config)

    # Save as YAML files
    dir.create("deployment/kubernetes", recursive = TRUE, showWarnings = FALSE)

    yaml::write_yaml(k8s_config$namespace, "deployment/kubernetes/00-namespace.yaml")
    yaml::write_yaml(k8s_config$configmap, "deployment/kubernetes/01-configmap.yaml")
    yaml::write_yaml(k8s_config$secret, "deployment/kubernetes/02-secret.yaml")
    yaml::write_yaml(k8s_config$deployment, "deployment/kubernetes/03-deployment.yaml")
    yaml::write_yaml(k8s_config$service, "deployment/kubernetes/04-service.yaml")
    yaml::write_yaml(k8s_config$ingress, "deployment/kubernetes/05-ingress.yaml")

    cat("✅ Generated Kubernetes manifests\n")

  } else {
    cat("⚠️ Unsupported provider:", provider, "\n")
    return(FALSE)
  }

  # Generate deployment script
  deployment_script <- generate_deployment_script(provider)
  writeLines(deployment_script, paste0("deployment/", provider, "_deploy.sh"))
  Sys.chmod(paste0("deployment/", provider, "_deploy.sh"), mode = "0755")

  cat("✅ Generated deployment script\n")

  # Generate Docker Compose for development
  compose_config <- generate_docker_compose_dev(config)
  writeLines(compose_config, "deployment/docker-compose.dev.yml")

  cat("✅ Generated Docker Compose for development\n")

  cat("🎉 Cloud infrastructure configuration complete!\n")
  cat("📋 Next steps:\n")
  cat("  1. Review generated configuration files\n")
  cat("  2. Update credentials and settings as needed\n")
  cat("  3. Run: ./deployment/", provider, "_deploy.sh\n")

  return(TRUE)
}

#' Deploy application to cloud
#'
#' @param provider Cloud provider
#' @param environment Deployment environment
#' @return Deployment status
deploy_to_cloud <- function(provider = "aws", environment = "production") {

  cat("🚀 Deploying to", toupper(provider), environment, "environment...\n")

  # Check if infrastructure exists
  if (provider == "aws") {
    # Check if Terraform state exists
    if (!file.exists("deployment/terraform/terraform.tfstate")) {
      cat("❌ Infrastructure not found. Run 'create_cloud_infrastructure()' first.\n")
      return(FALSE)
    }

    # Apply Terraform configuration
    setwd("deployment/terraform")

    result <- system("terraform init", intern = TRUE)
    if (attr(result, "status") != 0) {
      cat("❌ Terraform init failed\n")
      setwd("../..")
      return(FALSE)
    }

    result <- system("terraform plan", intern = TRUE)
    if (attr(result, "status") != 0) {
      cat("❌ Terraform plan failed\n")
      setwd("../..")
      return(FALSE)
    }

    result <- system("terraform apply -auto-approve", intern = TRUE)
    if (attr(result, "status") != 0) {
      cat("❌ Terraform apply failed\n")
      setwd("../..")
      return(FALSE)
    }

    setwd("../..")

    # Run deployment script
    deployment_script <- paste0("deployment/", provider, "_deploy.sh")
    if (file.exists(deployment_script)) {
      result <- system(deployment_script, intern = TRUE)
      if (attr(result, "status") == 0) {
        cat("✅ Deployment successful!\n")
        return(TRUE)
      } else {
        cat("❌ Deployment script failed\n")
        return(FALSE)
      }
    }

  } else {
    cat("⚠️ Deployment not implemented for provider:", provider, "\n")
    return(FALSE)
  }

  return(TRUE)
}

#' Monitor cloud deployment
#'
#' @param provider Cloud provider
#' @return Monitoring status
monitor_cloud_deployment <- function(provider = "aws") {

  cat("📊 Monitoring cloud deployment...\n")

  if (provider == "aws") {
    # Check ECS service status
    cluster_name <- paste0(CLOUD_CONFIG$app_name, "-cluster")
    service_name <- paste0(CLOUD_CONFIG$app_name, "-service")

    # Check service status
    service_status <- system(paste0(
      "aws ecs describe-services --cluster ", cluster_name,
      " --services ", service_name,
      " --query 'services[0].deployments[0].rolloutState' --output text"
    ), intern = TRUE)

    cat("ECS Service Status:", service_status, "\n")

    # Check load balancer health
    lb_dns <- system(paste0(
      "aws elbv2 describe-load-balancers --names ", CLOUD_CONFIG$app_name, "-alb",
      " --query 'LoadBalancers[0].DNSName' --output text"
    ), intern = TRUE)

    if (lb_dns != "") {
      health_status <- system(paste0("curl -s http://", lb_dns, "/health"), intern = TRUE)
      cat("Load Balancer Health:", health_status, "\n")
    }

    # Check database status
    db_status <- system(paste0(
      "aws rds describe-db-instances --db-instance-identifier ", CLOUD_CONFIG$app_name, "-db",
      " --query 'DBInstances[0].DBInstanceStatus' --output text"
    ), intern = TRUE)

    cat("Database Status:", db_status, "\n")

  } else {
    cat("⚠️ Monitoring not implemented for provider:", provider, "\n")
  }
}

#' Scale cloud deployment
#'
#' @param provider Cloud provider
#' @param desired_instances Number of desired instances
#' @return Scaling status
scale_cloud_deployment <- function(provider = "aws", desired_instances = NULL) {

  if (is.null(desired_instances)) {
    desired_instances <- CLOUD_CONFIG$desired_instances
  }

  cat("🔄 Scaling deployment to", desired_instances, "instances...\n")

  if (provider == "aws") {
    cluster_name <- paste0(CLOUD_CONFIG$app_name, "-cluster")
    service_name <- paste0(CLOUD_CONFIG$app_name, "-service")

    result <- system(paste0(
      "aws ecs update-service --cluster ", cluster_name,
      " --service ", service_name,
      " --desired-count ", desired_instances
    ), intern = TRUE)

    if (attr(result, "status") == 0) {
      cat("✅ Scaling initiated successfully\n")
      return(TRUE)
    } else {
      cat("❌ Scaling failed\n")
      return(FALSE)
    }
  }

  return(TRUE)
}

#' Backup cloud deployment
#'
#' @param provider Cloud provider
#' @return Backup status
backup_cloud_deployment <- function(provider = "aws") {

  cat("💾 Creating cloud deployment backup...\n")

  if (provider == "aws") {
    # Create RDS snapshot
    snapshot_id <- paste0(CLOUD_CONFIG$app_name, "-backup-", format(Sys.time(), "%Y%m%d-%H%M"))

    result <- system(paste0(
      "aws rds create-db-snapshot --db-instance-identifier ", CLOUD_CONFIG$app_name, "-db",
      " --db-snapshot-identifier ", snapshot_id
    ), intern = TRUE)

    if (attr(result, "status") == 0) {
      cat("✅ Database backup created:", snapshot_id, "\n")
    }

    # Create EFS backup (if applicable)
    # Implementation depends on storage configuration
  }

  return(TRUE)
}

#' Generate cloud deployment documentation
#'
#' @param provider Cloud provider
#' @return Documentation content
generate_cloud_documentation <- function(provider = "aws") {

  doc_content <- paste0(
    "# Cloud Deployment Documentation - ", toupper(provider), "\n",
    "===========================================\n\n",

    "## Overview\n\n",
    "This document describes the cloud deployment of the NHANES BMI Body Fat Analysis Platform on ", toupper(provider), ".\n\n",

    "## Architecture\n\n",
    "### Infrastructure Components\n",
    "- **ECS Cluster**: Container orchestration with auto-scaling\n",
    "- **Application Load Balancer**: Traffic distribution and SSL termination\n",
    "- **RDS PostgreSQL**: Relational database for application data\n",
    "- **S3 Storage**: Scalable object storage for data files and backups\n",
    "- **CloudWatch**: Comprehensive monitoring and alerting\n",
    "- **VPC**: Isolated and secure network environment\n",
    "- **IAM**: Role-based access control and security\n\n",

    "## Deployment Process\n\n",
    "### Prerequisites\n",
    "1. AWS CLI configured with appropriate credentials and permissions\n",
    "2. Terraform installed (for infrastructure provisioning)\n",
    "3. Docker installed and configured\n",
    "4. Appropriate IAM permissions for ECS, RDS, S3, CloudWatch\n\n",

    "### Step 1: Infrastructure Provisioning\n",
    "```bash\n",
    "cd deployment/terraform\n",
    "terraform init\n",
    "terraform plan\n",
    "terraform apply -auto-approve\n",
    "```\n\n",

    "### Step 2: Application Deployment\n",
    "```bash\n",
    "# Build and push Docker image to ECR\n",
    "./deployment/aws_deploy.sh\n",
    "```\n\n",

    "### Step 3: Verification and Testing\n",
    "```bash\n",
    "# Check ECS service deployment status\n",
    "aws ecs describe-services --cluster ", CLOUD_CONFIG$app_name, "-cluster --services ", CLOUD_CONFIG$app_name, "-service\n\n",
    "# Test API health endpoint\n",
    "curl http://<load-balancer-dns>/health\n",
    "\n",
    "# Check database connectivity\n",
    "aws rds describe-db-instances --db-instance-identifier ", CLOUD_CONFIG$app_name, "-db\n",
    "```\n\n",

    "## Auto-Scaling Configuration\n\n",
    "### Scaling Policies\n",
    "- **CPU-based Scaling**: Triggers at 70% CPU utilization\n",
    "- **Memory-based Scaling**: Triggers at 80% memory utilization\n",
    "- **Scale Range**: ", CLOUD_CONFIG$min_instances, "-", CLOUD_CONFIG$max_instances, " instances\n",
    "- **Cooldown Period**: 300 seconds between scaling activities\n\n",

    "### Manual Scaling\n",
    "```bash\n",
    "# Scale to specific number of instances\n",
    "aws ecs update-service --cluster ", CLOUD_CONFIG$app_name, "-cluster \\\n",
    "  --service ", CLOUD_CONFIG$app_name, "-service \\\n",
    "  --desired-count <number>\n",
    "```\n\n",

    "## Monitoring and Alerting\n\n",
    "### CloudWatch Metrics\n",
    "- **ECS Service Metrics**: CPU, memory, task count, running tasks\n",
    "- **Load Balancer Metrics**: Request count, response time, error rate\n",
    "- **RDS Metrics**: CPU, memory, connections, read/write latency\n",
    "- **Custom Application Metrics**: Analysis completion time, error rates\n\n",

    "### Configured Alarms\n",
    "- **High CPU Usage**: >80% for 2 consecutive periods\n",
    "- **High Memory Usage**: >85% for 2 consecutive periods\n",
    "- **Service Health**: Failed health checks\n",
    "- **Database Connectivity**: Connection failures\n",
    "- **Error Rate**: >5% HTTP 5xx errors\n\n",

    "### Monitoring Commands\n",
    "```bash\n",
    "# View service metrics\n",
    "aws cloudwatch get-metric-statistics --namespace AWS/ECS --metric-name CPUUtilization \\\n",
    "  --dimensions Name=ServiceName,Value=", CLOUD_CONFIG$app_name, "-service \\\n",
    "  --start-time $(date -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \\\n",
    "  --end-time $(date +%Y-%m-%dT%H:%M:%S) --period 300 --statistics Average\n",
    "\n",
    "# Check active alarms\n",
    "aws cloudwatch describe-alarms --alarm-names ", CLOUD_CONFIG$app_name, "-*\n",
    "```\n\n",

    "## Backup and Recovery\n\n",
    "### Automated Backups\n",
    "- **RDS Snapshots**: Daily automated snapshots (7-day retention)\n",
    "- **S3 Versioning**: Enabled for all data buckets\n",
    "- **Cross-Region Replication**: Optional for disaster recovery\n",
    "- **Backup Window**: 03:00-04:00 UTC daily\n\n",

    "### Manual Backup Procedures\n",
    "```bash\n",
    "# Create manual database snapshot\n",
    "aws rds create-db-snapshot \\\n",
    "  --db-instance-identifier ", CLOUD_CONFIG$app_name, "-db \\\n",
    "  --db-snapshot-identifier ", CLOUD_CONFIG$app_name, "-manual-$(date +%Y%m%d-%H%M)\n",
    "\n",
    "# List available snapshots\n",
    "aws rds describe-db-snapshots \\\n",
    "  --db-instance-identifier ", CLOUD_CONFIG$app_name, "-db\n",
    "```\n\n",

    "## Security Configuration\n\n",
    "### Network Security\n",
    "- **VPC Isolation**: Private subnets for application and database\n",
    "- **Security Groups**: Least-privilege access rules\n",
    "- **Network ACLs**: Additional traffic filtering\n",
    "- **SSL/TLS Encryption**: HTTPS for all web traffic\n",
    "- **Certificate Management**: AWS Certificate Manager integration\n\n",

    "### Access Control\n",
    "- **IAM Roles**: Task-specific permissions for ECS tasks\n",
    "- **Database Credentials**: Secure credential management\n",
    "- **API Key Authentication**: Token-based API access (optional)\n",
    "- **Audit Logging**: Complete activity tracking\n",
    "- **Data Encryption**: At-rest and in-transit encryption\n\n",

    "## Cost Optimization\n\n",
    "### Current Configuration Costs\n",
    "- **ECS Fargate**: $", round(CLOUD_CONFIG$desired_instances * 0.04048 * 24 * 30, 2), " (", CLOUD_CONFIG$desired_instances, " × ", CLOUD_CONFIG$instance_type, ")\n",
    "- **RDS Database**: $", round(0.018 * 24 * 30, 2), " (", CLOUD_CONFIG$database$instance_class, ")\n",
    "- **Load Balancer**: $", round(0.0225 * 24 * 30, 2), "\n",
    "- **S3 Storage**: $", round(0.023 * 20, 2), " (20GB)\n",
    "- **CloudWatch**: $", round(0.30 * 30, 2), "\n",
    "- **Data Transfer**: $0.09/GB (first 100GB free)\n",
    "- **Total Estimated: ~$", round(CLOUD_CONFIG$desired_instances * 0.04048 * 24 * 30 + 0.018 * 24 * 30 + 0.0225 * 24 * 30 + 0.023 * 20 + 0.30 * 30, 2), "**\n\n",

    "### Cost Optimization Strategies\n",
    "- **Fargate Spot**: Use spot instances for non-critical workloads\n",
    "- **Right-Sizing**: Monitor and adjust instance sizes\n",
    "- **Auto-Scaling**: Scale down during low usage periods\n",
    "- **Reserved Instances**: 1-3 year commitments for predictable workloads\n",
    "- **Data Lifecycle**: Move old data to Glacier for cost savings\n\n",

    "## Troubleshooting\n\n",
    "### Common Deployment Issues\n",
    "1. **ECS Service Not Starting**: Check CloudWatch logs for application errors\n",
    "2. **Load Balancer Health Checks Failing**: Verify container health endpoint\n",
    "3. **Database Connection Issues**: Check security group rules and credentials\n",
    "4. **High Memory Usage**: Monitor ECS task metrics and adjust memory allocation\n",
    "5. **Network Connectivity**: Verify VPC and subnet configurations\n\n",

    "### Debug Commands\n",
    "```bash\n",
    "# Check ECS service status and events\n",
    "aws ecs describe-services --cluster ", CLOUD_CONFIG$app_name, "-cluster --services ", CLOUD_CONFIG$app_name, "-service\n",
    "aws ecs describe-tasks --cluster ", CLOUD_CONFIG$app_name, "-cluster --tasks <task-arn>\n\n",
    "# View application logs\n",
    "aws logs tail /ecs/", CLOUD_CONFIG$app_name, " --follow\n\n",
    "# Check database status and logs\n",
    "aws rds describe-db-instances --db-instance-identifier ", CLOUD_CONFIG$app_name, "-db\n",
    "aws logs describe-log-groups --log-group-name-prefix /aws/rds\n\n",
    "# Monitor load balancer health\n",
    "aws elbv2 describe-target-health --target-group-arn <target-group-arn>\n",
    "```\n\n",

    "## Maintenance Procedures\n\n",
    "### Regular Tasks\n",
    "- **Daily**: Monitor CloudWatch metrics and respond to alerts\n",
    "- **Weekly**: Review cost reports and optimize resource usage\n",
    "- **Monthly**: Update application images and test deployments\n",
    "- **Quarterly**: Review security configurations and access patterns\n",
    "- **Annually**: Comprehensive infrastructure audit and optimization\n\n",

    "### Application Updates\n",
    "```bash\n",
    "# Build new Docker image\n",
    "docker build -t ", CLOUD_CONFIG$app_name, ":latest .\n\n",
    "# Push to ECR\n",
    "aws ecr get-login-password --region ", CLOUD_CONFIG$region, " | docker login --username AWS --password-stdin \\\n",
    "  $(aws sts get-caller-identity --query Account --output text).dkr.ecr.", CLOUD_CONFIG$region, ".amazonaws.com\n",
    "docker tag ", CLOUD_CONFIG$app_name, ":latest $(aws sts get-caller-identity --query Account --output text).dkr.ecr.", CLOUD_CONFIG$region, ".amazonaws.com/", CLOUD_CONFIG$app_name, ":latest\n",
    "docker push $(aws sts get-caller-identity --query Account --output text).dkr.ecr.", CLOUD_CONFIG$region, ".amazonaws.com/", CLOUD_CONFIG$app_name, ":latest\n\n",
    "# Deploy new version\n",
    "aws ecs update-service --cluster ", CLOUD_CONFIG$app_name, "-cluster --service ", CLOUD_CONFIG$app_name, "-service --force-new-deployment\n",
    "```\n\n",

    "## Performance Monitoring\n\n",
    "### Key Performance Indicators\n",
    "- **Response Time**: < 500ms for API calls\n",
    "- **Uptime**: 99.9% service availability\n",
    "- **Error Rate**: < 1% for all requests\n",
    "- **Resource Utilization**: CPU < 70%, Memory < 80%\n",
    "- **Database Performance**: Query time < 100ms\n\n",

    "### Performance Optimization\n",
    "- **Load Balancer**: Distribute traffic across multiple availability zones\n",
    "- **Database**: Read replicas for read-heavy workloads\n",
    "- **Caching**: Redis for session and computation caching\n",
    "- **CDN**: CloudFront for static content delivery\n",
    "- **Compression**: Enable gzip compression for API responses\n\n",

    "## Support and Escalation\n\n",
    "### Getting Help\n",
    "1. **Check CloudWatch Logs**: `/ecs/", CLOUD_CONFIG$app_name, "` for application errors\n",
    "2. **Review ECS Events**: Service deployment and scaling events\n",
    "3. **Monitor Alarms**: CloudWatch alarm status and history\n",
    "4. **Check Metrics**: CPU, memory, and custom application metrics\n\n",

    "### Emergency Procedures\n",
    "1. **Immediate**: Check service health via load balancer\n",
    "2. **Quick Diagnosis**: Review CloudWatch metrics for anomalies\n",
    "3. **Log Analysis**: Examine application logs for error patterns\n",
    "4. **Resource Scaling**: Scale up instances if resource-constrained\n",
    "5. **Escalation**: Contact on-call engineer for critical issues\n",
    "6. **Communication**: Notify stakeholders of service impact\n\n",

    "### Contact Information\n",
    "- **DevOps Team**: devops@nhanes-bmi.org\n",
    "- **Emergency**: emergency@nhanes-bmi.org\n",
    "- **Documentation**: https://docs.nhanes-bmi.org/deployment\n",
    "- **Status Page**: https://status.nhanes-bmi.org\n\n",

    "---\n\n",
    "*This deployment provides a scalable, reliable, and cost-effective cloud infrastructure for the NHANES BMI Body Fat Analysis platform, designed for enterprise-grade epidemiological research.*"
  )

  return(doc_content)
}

#' Main cloud deployment function
#'
#' @param action Deployment action ("create", "deploy", "monitor", "scale", "backup")
#' @param provider Cloud provider
#' @param environment Deployment environment
#' @return Deployment result
main_cloud_deployment <- function(action = "create", provider = "aws", environment = "production") {

  switch(action,
    "create" = {
      success <- create_cloud_infrastructure(provider, CLOUD_CONFIG)
      if (success) {
        cat("🎉 Infrastructure creation complete!\n")
        cat("📋 Next: Run deployment with 'deploy_to_cloud()'\n")
      }
    },
    "deploy" = {
      success <- deploy_to_cloud(provider, environment)
      if (success) {
        cat("🚀 Deployment complete!\n")
        cat("🌐 Application should be accessible shortly\n")
      }
    },
    "monitor" = {
      monitor_cloud_deployment(provider)
    },
    "scale" = {
      success <- scale_cloud_deployment(provider)
      if (success) {
        cat("🔄 Scaling operation initiated\n")
      }
    },
    "backup" = {
      success <- backup_cloud_deployment(provider)
      if (success) {
        cat("💾 Backup completed\n")
      }
    },
    "docs" = {
      doc_content <- generate_cloud_documentation(provider)
      writeLines(doc_content, paste0("deployment/", provider, "_deployment_docs.md"))
      cat("📖 Documentation generated\n")
    },
    {
      cat("❌ Unknown action:", action, "\n")
      cat("Available actions: create, deploy, monitor, scale, backup, docs\n")
      return(FALSE)
    }
  )

  return(TRUE)
}

# Run cloud deployment if script is executed directly
if (!interactive()) {
  args <- commandArgs(trailingOnly = TRUE)

  if (length(args) >= 1) {
    action <- args[1]
    provider <- if (length(args) >= 2) args[2] else "aws"
    environment <- if (length(args) >= 3) args[3] else "production"

    main_cloud_deployment(action, provider, environment)
  } else {
    cat("Usage: Rscript deployment/cloud_deployment.R <action> [provider] [environment]\n")
    cat("Actions: create, deploy, monitor, scale, backup, docs\n")
    cat("Provider: aws, gcp, azure (default: aws)\n")
    cat("Environment: production, staging, development (default: production)\n")
  }
}

